%\subsection{ASP}\label{sec:asp}

\ASP{}~\cite{2003_BARAL_BOOK} is a form of declarative programming %that is focused on 
for solving difficult search problems. 
It operates by defining problems in terms of rules and constraints, then computing the ``answer sets'' which are collections of assumptions that satisfy rules and constraints without contradiction.
%ASP is particularly useful in areas like artificial intelligence, where it can model complex problems and reason about them effectively.
The programmer specifies the desired properties of the solution in a high-level language, and the \ASP{} system automatically searches for all solutions that meet these criteria, making it a powerful tool for knowledge representation and reasoning tasks. 
\ASP{} has been used to address timetabling problems proposed in the \ITC{}-2007 competition
~\cite{2019_banbara_AOR}.
%ASP is a powerful approach for scheduling problems. 
The \ASP{} program we propose for \UTP{}  
%The program will be used in our experimental study at section~\ref{sec:experiments}. 
(see appendix~\ref{appendix:ASP} for the full program)
has been developed with clingo - an \ASP{} solver - and clingcon - a constraint answer set programing solver.

%Il est possible de distinguer trois grande famille de solveur ASP. La première représentée par Clingo~\cite{Clingo2017Gebser} consiste à transformer le programme ASP en un programme propositionnel (Phase de grounding) avant de le résoudre par un algorithme inspiré de la résolution de problème SAT. La deuxième est représenté par les solveurs qui font du grounding à la volé tel que ASPeRiX, GASP, OMiGa. La troisième méthode de résolution consiste à traduire un programme ASP dans un autre formalisme. 
%Voic une Liste non exhaustive de solveur ASP : Clingo, DLV, OMiGA, GASP, Smodels, Cmodels, CHRASPERIX
% Utilisation du modèle définis par BanBarra et alListing 1.1), suivi des règles associées à la résolution du problème. Dans la lit-.
% Cependant ici l'horizon temporel est différent
%Dans cette section, nous présenterons %d'abord le modèle de données ASP (voir Listing~\ref{lst:data-asp}), suivi des 
%quelques règles associées à la résolution du problème. Dans la littérature il existe un modèle~\cite{2019_banbara_AOR}, qui résout le problème d'\EDT{} en se basant sur le problème ITC-2007 en ASP.
%In this section, % we will first present the ASP data model (see Listing~\ref{lst:data-asp}), 
%presents by several rules associated with solving the problem. In the literature, there exists a model~\cite{2019_banbara_AOR} that solves the EDT problem based on the ITC-2007 problem in ASP.
% Cependant, il est important de noter que l'horizon temporel du problème UTP est différent. 
%\input{4-2-1-model-asp}
%La première série de règle exprime les valeurs de l'horizon réel  (\verb|weeks(nrWeeks)|, \verb|days(nrDays)| ,\verb|slot_per_day(nrDailySlots)| utilisé par le problème \EDT{} puis \verb|grid(minCréneau,écartCréneau,nrCréneau)| la grille qui est une simplification de l'horizon réel permettant de travailler dans des dimensions plus petite. 
%Les autres valeurs concernent la maquette avec le nombre de cours, de parties de cours, de classes et de séances de cours.

%Les ressources sont répertoriées sous forme de prédicats \\(\verb|room(id-room,Capacité)|,\verb|teacher(id-teacher)|)
%Les parties de cours portent les informations suivantes:\\\verb|part(id-part,nrSéances, DuréeSéance,|\\\verb|nrRoomsParSéance,nrJours,nrSemaines,|\\ \verb|nrTeachersParSéance)|. 
%Les prédicats \verb|course_part|, \verb|part_class|, \verb|class_sessions|  définissent la structure hiérarchique de chaque élément de la maquette, explicitant ainsi les relations et héritages entre eux.
%Les ressources de chaque partie de cours sont énoncées à l'aide des prédicats  \verb|part_teacher(id-part,id-teacher)| et \verb|part_room(id-part,id-room)|.
%Pour définir l'ensemble des créneaux horaires disponibles pour résoudre le problème, nous spécifions les jours de la semaine potentiels, ainsi que les semaines disponibles pour l'utilisation (\verb|part_days(id-part,jour)|, \verb|part_weeks(id-part,semaine)| pour les semaines), et l'ensemble des créneaux horaires quotidiens (\verb|part_slots(id-part,créneau)|).
%Dans le prétraitement nous embarquons un réducteur de temps produisant une grille simplifiée \\\verb|part_grids(id-part,minCréneau,durée,|\\\verb|nrCréneau)| qui est version réduite de la grille totale.
%Nous listons également les groupes (\verb|group(id-group,headcount)|), et
%nous affectons les différents groupes aux classes des parties de cours (\verb|class_groups(id-class,id-group)|).
%Par simplification nous énonçons dans la section\verb|%%SESSIONS RACCOURCI| , un ensemble de règles qui viennent simplifier l'écriture des contraintes du modèle de résolution.
%Enfin dans la partie \verb|%%CONTRAINTES|, nous énonçons quelques contraintes pour ce modèle, mais elles suivent le même format que celles du schéma \UTP{}.

%\input{3-1-1-model}

%La règle~\ref{lst:rule-asp} permet de faire un choix ASP sur le créneau horaire de départ des séances.
%Pour chaque séance $s \in \SESSION$, un unique prédicat représentant l'assignation d'un horaire à une séance est générée (\verb|assigned(Séance, Créneau)|). L'unicité de ce prédicat est assuré dans la tête de la règle. Les autres ressources salles et enseignants sont quant à elle déclaré respectivement via les prédicats \verb|assignedr| et \verb|assignedt|.
%
%Rule~\ref{lst:rule-asp} allows for an \ASP{} choice regarding the starting time slot of sessions. For each session $s \in \SESSION$, a unique predicate representing the assignment of a time slot to a session is generated (\verb|assigned(Session, TimeSlot)|). The singularity of this predicate is ensured in the head of the rule. Other resources such as rooms and teachers are declared respectively using the predicates \verb|assignedr| and \verb|assignedt|.

%\begin{lstlisting}[style=PrologStyle, caption={Règle ASP choix créneau}, label={lst:rule-asp}]
%   1{ assigned(S,SL) : session_part(S,P), part_slot(P,SL) }1 :- session(S).
%   1{ assignedr(S,SL,R,K) : session_part(S,P), part_room(P,R) }1 :- assigned(S,SL).
%   1{ assignedt(S,SL,T,K) : session_part(S,P), part_teacher(P,T) }1 :- assigned(S,SL).
%\end{lstlisting}
%Concernant l'affectation des salles et des enseignants qui peuvent être des ressources multiples, nous avons une structure pour le faire (trouvable en appendix).
%
%Regarding the assignment of rooms and teachers, which can be multiple resources, we have a structure to handle it (found in the appendix).
%
%We will now proceed to review some constraints.
%Dans cet exemple nous faisons des hypothèses simplificatrice nous estimons que le nombre exact par séances de la ressource est connu (p.ex. 2 salles par séance).
%In the general case, we express the no\_overlap constraint by making an order choice between the sessions. This compels the sessions to be ordered to prevent them from occurring simultaneously. "Sequenced" is a special case where the value of 0 or 1 is fixed.
%

%\begin{lstlisting}[style=PrologStyle, caption={Ressource exclusive-general-ASP}, label={lst:disjunctivergeneralessource-asp}]
%:- sequenced_ch(S1,S2,0), assigned(S2,K2), assigned(S1,K1), session_part(S1,P), part_grids(P,_,N,_), K2-K1 < N.
%
%:- sequenced_ch(S1,S2,1), assigned(S2,K2), assigned(S1,K1), session_part(S2,P), part_grids(P,_,N,_), K1-K2 < N.
%
%1{sequenced_ch(S1,S2,X) : num(X)}1 :- disjunctive_group(S1,G), disjunctive_group(S2,G), assignedr(S1,SL1), assignedr(S2,SL2), S1 < S2,not sequenced(S1,S2), not sequenced(S2,S1).
%\end{lstlisting}
%
%Pour vérifier si une salle assignée à une séance est valide nous déclarons une contrainte permettant de vérifier si la taille d'une salle allouée accepte l'effectif étudiant associé à une séance de cours. Une deuxième contrainte permet de traiter les cas multi-room en utilisant le predicat \verb|#sum{I,K:valeur(I,K)}| qui effectue une somme.
%
%\begin{lstlisting}[style=PrologStyle, caption={Ressource exclusive-ASP}, label={lst:disjunctiveressource-asp}]
%:- assignedr(S,SL,R,1), room(R,C1), sessionRoomFix(S), session_class(S,C), class_headcount(C,N), N > C1.
%:- assignedr(S,SL,R), room(R,C1), session_class(S,C), class_headcount(C,N), N > C1.
%\end{lstlisting}
%
%On utilise le predicat \verb|#count{I,K:valeur(I,K)}| qui permet d'effectuer un comptage sur un ensemble donné en entrée. Il est utilisé dans la constraint requiredTeacher et dans des vérifications d'ordre sur les cas multi-rooms. 

%Cependant dans le cas où l'écart entre les tous les créneaux horaires est plus grand que toutes les durées de séance de cours, nous pouvons poser les contraintes suivantes~\ref{lst:disjunctiveressource-asp}. Elles permettent elles d'éviter d'avoir plusieurs séances qui se chevauchent en utilisant des spécificité du langage.
%
%However, in cases where features nooverlap(\hyperref[featmodel:nooverlap]{``nooverlap''}) is valid, we can impose the following constraints~\ref{lst:disjunctiveressource-asp}. They help avoid multiple overlapping sessions by utilizing the language's specificities.
%
%\begin{lstlisting}[style=PrologStyle, caption={Ressource exclusive-ASP}, label={lst:disjunctiveressource-asp}]
%:- not {assignedr(S,SL,R,1) : session(S), disjunctive_room(R,S) } 1 :-  slots(SL), room(R,_).
%\end{lstlisting}



%=========================
% \begin{lstlisting}[style=PrologStyle, caption={Multi-room ASP}, label={lst:multiroom-asp}]
% nrPositionRoom(S,1..N):- session(S), nrRoomMax(S,N).
% nrRoomMax(S,N):- session(S),session_part(S,P), part(P,_,_,_,_,N,_), N > 1.
% 1{assignedrk(S,SL,I) : nrPositionRoom(S,I)}K :- assigned(S,SL), nrRoomMax(S,K).
% 1{assignedr(S,SL,R,I) : session_room(S,R), nrPositionRoom(S,I)}1 :- assignedrk(S,SL,I).
% roomOrdered(S,1..N):- session(S), same_rooms(S,_), nrRoomMax(S,K), N = #count{S,I:assignedr(S,_,_,I)}.
% :- roomOrdered(S,I), not assignedr(S,_,_,I).
% :- assignedr(S,_,R,K2), assignedr(S,_,R,K1), K1 != K2.
% \end{lstlisting}

%Pour ce faire nous définissons un ensemble de taille  L pour les séances qui nécessitent d'avoir plusieurs salles. %Chaque ensemble de \verb|assignedrk|.
%Cette ensemble de taille L, contient un minimum de de K1 (possiblement 0) salles et un maximum de K2 salles.
%Il faut alors créer pour chaque séance le nombre K1 minimum de salle nécessaire et au plus K2 (cela crée donc K1 \verb|assignedr| et un maximum de K2).
%Pour chaque k$ \in$ L (donc \verb|assignedrk|) il faut affecter une salle à la séance.
%Cette information supplémentaire nous permet d'accéder aux différentes valeurs de l'ensemble crée. 
%Cela permet de minimiser la combinatoire et d'éviter d'avoir une contrainte vérifiant qu'une combinaison ne génère pas deux fois la même prédicat \verb|assignedr| avec un même k ayant des salles différentes. 
%De plus, pour s'assurer que les séances nécessitant d'être comparées sont bien ordonnés de 1 à |L|, nous ajoutons des contraintes qui obligent les valeurs choisies à être correctement ordonnées.
%Cependant, ces contraintes d'ordre ne semblent pas avoir d'impact sur la résolution, car de fait les valeurs semblent choisies dans cet ordre.
%

%%%%%%%%%%%%%
% To do this, we define a set of size L for sessions that require multiple rooms. Each set of \verb|assignedrk| contains a minimum of K1 (possibly 0) rooms and a maximum of K2 rooms. Therefore, for each session, we need to create a minimum of K1 rooms and at most K2 (this creates K1 \verb|assignedr| and a maximum of K2). For each k$ \in$ L (thus \verb|assignedrk|), a room needs to be assigned to the session. This additional information allows us to access the different values of the created set. 


%This minimizes combinatorics and avoids having a constraint that checks whether a combination generates the same \verb|assignedr| predicate twice with the same k having different rooms.
%
%%%%%%%%%%%%%%%%%
% This reduces combinatorial complexity and prevents the need for a constraint to verify if the same combination produces duplicate \verb|assignedr| predicates with different rooms for the same k.



%Furthermore, to ensure that sessions requiring comparison are correctly ordered from 1 to |L|, we add constraints that enforce the chosen values to be correctly ordered. 
%However, these ordering constraints do not seem to have an impact on resolution, as the values seem to be chosen in this order by default.
%


%======================

%Pour la contrainte de capacité des salles, nous pouvons déclarer la contraintes ASP dans un cas multi-room et mono-room.
%Dans un cas multi-room nous vérifions via une somme (un agrégat) que la capacité des salles cumulé peut accueillir la séance.
%\begin{lstlisting}[style=PrologStyle, caption={Room capacity-ASP}, label={lst:cumulativeroomcapacity-asp}]
%    :- nrRoomMax(S,_), session_class(S,C), class_headcount(C,N), N > #sum{V,I : assignedr(S,_,R,I), room(R,V)}.
%\end{lstlisting}

%Dans le cas général, nous exprimons la contrainte no\_overlap en effectuant un choix d'ordre entre les séances. De cette manière, nous obligeons les séances à être ordonnées pour éviter qu'elles aient lieu en même temps.
%


%Cela permet de laisser au solveur de faire un choix sur l'ordre des séances.
%En effet s'il y'a un disjunction énoncé dans les contraintes, alors on fait un choix usr l'ordre des séances pour éviter qu'elle est lieu en même temps.


 %\begin{lstlisting}[style=PrologStyle, caption={Periodic ASP}, label={lst:periodic-asp}]
%:- periodic(S1,S2,N), assigned(S1,SL1), assigned(S2,SL2), SL2 != SL1+N.
 %\end{lstlisting}
%La contrainte~\ref{lst:periodic-asp} applique la périodicité de valeur N entre les séances, correspondant à la contrainte~\ref{formal:periodic}.
 
% \begin{lstlisting}[style=PrologStyle, caption={Sequenced ASP}, label={lst:sequenced-asp}]
%:- sequenced(S1,S2), assigned(S1,SL1), session_part(S1,P), part_grids(P,_,N,_), assigned(S2,SL2), SL1+N > SL2.
%sequenced(S1,S2) :- part(P,_,_,_,_,_,_), part_class(P,C), class_sessions(C,S1), class_sessions(C,S2), S1+1 = S2.
 %\end{lstlisting}
 %Pour exprimer le séquencement~\ref{formal:sequenced} l'encodage est quasiment direct~\ref{lst:sequenced-asp}.
% \begin{lstlisting}[style=PrologStyle, caption={Same ressource ASP}, label={lst:sameressource-asp}]
%:- same_slot(S1,S2), assigned(S1,SL1), assigned(S2,SL2), SL1 != SL2.
%:- same_teachers(S1,S2), assignedt(S1,_,T1,K), assignedt(S2,_,T2,K), T1 != T2.
%:- same_rooms(S1,S2), assignedr(S1,_,R1,K), assignedr(S2,_,R2,K), R1 != R2.
%:- same_rooms(S,S2), nrRoomMax(S,_), not nrRoomMax(S2,_).
% \end{lstlisting}
%La liste de contraintes~\ref{lst:sameressource-asp} permet de représenter les contraintes d'égalité ~\ref{formal:samerooms}~\ref{formal:sameteachers}~\ref{formal:sameslot}.
 %\begin{lstlisting}[style=PrologStyle, caption={Assign Ressource ASP}, label={lst:assignressource-asp}]
 %assigned(S1,T1) :- assign_slot(S1,T1).
%:- assign_rooms(S1,R1), assignedr(S1,_,R2,1), R1 != R2.
%:- assign_teachers(S1,T1), assignedt(S1,_,T2,1), T1 != T2.
% \end{lstlisting}
%Pour les différentes contraintes d'assignement~\ref{formal:assignrooms}~\ref{formal:assignslot} nous avons une version simplifié ne s'appliquant qu'aux cas mono-ressources~\ref{lst:assignressource-asp}.
% \begin{lstlisting}[style=PrologStyle, caption={Service teacher ASP}, label={lst:serviceteacher-asp}]
%:- serviceTeacher(T,P,N), #count { S,T :assignedt(S,_,T,_),part_sessions(P,S)} != N.
% \end{lstlisting}
%La contrainte~\ref{formal:requiredteacher} est exprimée par le prédicat (\verb|serviceTeacher(id-teacher,id-part,nrSéances)|) dans la liste~\ref{lst:serviceteacher-asp}.

%Des approches via modulo theorie (SMT) en utilisant le symbole \verb|&diff{T1,T2}<N| permettant d'utiliser des approches SMT pour aider à la résolution.